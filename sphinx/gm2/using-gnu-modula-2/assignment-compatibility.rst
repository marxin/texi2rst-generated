Assignment compatibility
^^^^^^^^^^^^^^^^^^^^^^^^

This section discusses the assignment issues surrounding assignment
compatibility of elementary types (``INTEGER``, ``CARDINAL``,
``REAL`` and ``CHAR`` for example).  The information here is
found in more detail in the Modula-2 ISO standard BS ISO/IEC
10514-1:1996 page 122.

Assignment compatibility exists between the same sized elementary
types.

Same type family of different sizes are
also compatible as long as the ``MAX(`` type ``)`` and
``MIN(`` type ``)`` is known.  So for example this includes the
``INTEGER`` family, ``CARDINAL`` family and the ``REAL``
family.

The reason for this is that when the assignment is performed
the compiler will check to see that the expression (on the right of
the ``:=``) lies within the range of the designator type (on the
left hand side of the ``:=``).  Thus these ordinal types can be
assignment compatible.  However it does mean that ``WORD32`` is not
compatible with ``WORD16`` as ``WORD32`` does not have a minimum
or maximum value and therefore cannot be checked.  The compiler does
not know which of the two bytes from ``WORD32`` should be copied
into ``WORD16`` and which two should be ignored.  Currently the
types ``BITSET8``, ``BITSET16`` and ``BITSET32`` are
assignment incompatible.  However this restriction maybe lifted when
further runtime checking is achieved.

Modula-2 does allow ``INTEGER`` to be assignment compatible with
``WORD`` as they are the same size.  Likewise GNU Modula-2 allows
``INTEGER16`` to be compatible with ``WORD16`` and the same for
the other fixed sized types and their sized equivalent in either
``WORD`` n, ``BYTE`` or ``LOC`` types.  However it prohibits
assignment between ``WORD`` and ``WORD32`` even though on many
systems these sizes will be the same.  The reasoning behind this rule
is that the extended fixed sized types are meant to be used by
applications requiring fixed sized data types and it is more portable
to forbid the bluring of the boundaries between fixed sized and
machine dependant sized types.

Intemediate code runtime checking is always generated by the front
end.  However this intemediate code is only translated into actual
code if the appropriate command line switches are specified.  This
allows the compiler to perform limited range checking at compile time.
In the future it will allow the extensive GCC optimisations to
propagate constant values through to the range checks which if they
are found to exceed the type range will result in a compile time
error message.

